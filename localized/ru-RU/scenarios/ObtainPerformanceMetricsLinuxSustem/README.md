---
title: Получение метрик производительности из системы Linux
description: 'Узнайте, как получить метрики производительности из системы Linux.'
author: divargas-msft
ms.author: esflores
editor: divargas-msft
ms.reviewer: divargas
ms.service: virtual-machines
ms.collection: linux
ms.topic: troubleshooting-general
ms.workload: infrastructure-services
ms.tgt_pltfrm: vm-linux
ms.date: 07/16/2024
ms.custom: 'devx-track-azurecli, mode-api, innovation-engine, linux-related-content'
---

# Получение метрик производительности из системы Linux

**Применимо к:** :heavy_check_mark: виртуальным машинам Linux

В этой статье рассматриваются инструкции по быстрому получению метрик производительности из системы Linux.

Существует несколько команд, которые можно использовать для получения счетчиков производительности в Linux. Такие команды, как `vmstat` и `uptime`, предоставляют общие системные метрики, такие как использование ЦП, системная память и загрузка системы.
Большинство команд уже устанавливаются по умолчанию с другими пользователями, которые легко доступны в репозиториях по умолчанию.
Команды можно разделить на:

* ЦП
* Память
* Операции дискового ввода-вывода
* Процессы

## Установка служебных программ sysstat

<!-- Commenting out these entries as this information should be selected by the user along with the corresponding subscription and region

The First step in this tutorial is to define environment variables, and install the corresponding package, if necessary.

```azurecli-interactive
export MY_RESOURCE_GROUP_NAME="myVMResourceGroup89f292"
export MY_VM_NAME="myVM89f292"
```
-->

> [!NOTE]
> Для сбора всех соответствующих сведений необходимо выполнить `root` некоторые из этих команд.

> [!NOTE]
> Некоторые команды являются частью `sysstat` пакета, который по умолчанию не может быть установлен. Пакет можно легко установить с `sudo apt install sysstat`помощью или `dnf install sysstat` `zypper install sysstat` для популярных дистрибутивов.

Полная команда для установки `sysstat` пакета на некоторых популярных дистрибутивах:

```bash
az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts "/bin/bash -c 'OS=\$(cat /etc/os-release|grep NAME|head -1|cut -d= -f2 | sed \"s/\\\"//g\"); if [[ \$OS =~ \"Ubuntu\" ]] || [[ \$OS =~ \"Debian\" ]]; then sudo apt install sysstat -y; elif [[ \$OS =~ \"Red Hat\" ]]; then sudo dnf install sysstat -y; elif [[ \$OS =~ \"SUSE\" ]]; then sudo zypper install sysstat --non-interactive; else echo \"Unknown distribution\"; fi'"
```

## ЦП

### <a id="mpstat"></a>mpstat

Программа `mpstat` является частью `sysstat` пакета. В нем отображаются показатели использования ЦП и средние значения, которые помогут быстро определить использование ЦП. `mpstat` предоставляет обзор использования ЦП на доступных ЦП, помогая определить баланс использования и если один ЦП сильно загружен.

Полная команда:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'mpstat -P ALL 1 2')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Параметры и аргументы:

* `-P`: указывает процессору для отображения статистики, аргумент ALL указывает на отображение статистики для всех сетевых ЦП в системе.
* `1`: первый числовой аргумент указывает, как часто обновлять отображение в секундах.
* `2`: второй числовой аргумент указывает, сколько раз обновляются данные.

Количество раз, `mpstat` когда команда отображает данные, можно изменить путем увеличения второго числового аргумента, чтобы обеспечить более длительное время сбора данных. В идеале должно быть достаточно 3 или 5 секунд, для систем с увеличенным числом ядер 2 секунды можно использовать для уменьшения объема отображаемых данных.
Из выходных данных:

```output
Linux 5.14.0-362.8.1.el9_3.x86_64 (alma9)       02/21/24        _x86_64_        (8 CPU)

16:55:50     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
16:55:51     all   69.09    0.00   30.16    0.00    0.38    0.38    0.00    0.00    0.00    0.00
16:55:51       0   77.23    0.00   21.78    0.00    0.99    0.00    0.00    0.00    0.00    0.00
16:55:51       1   97.03    0.00    0.99    0.00    0.99    0.99    0.00    0.00    0.00    0.00
16:55:51       2   11.11    0.00   88.89    0.00    0.00    0.00    0.00    0.00    0.00    0.00
16:55:51       3   11.00    0.00   88.00    0.00    0.00    1.00    0.00    0.00    0.00    0.00
16:55:51       4   83.84    0.00   16.16    0.00    0.00    0.00    0.00    0.00    0.00    0.00
16:55:51       5   76.00    0.00   23.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00
16:55:51       6   96.00    0.00    3.00    0.00    0.00    1.00    0.00    0.00    0.00    0.00
16:55:51       7  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
[...]

Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
Average:     all   74.02    0.00   25.52    0.00    0.25    0.21    0.00    0.00    0.00    0.00
Average:       0   63.00    0.00   36.67    0.00    0.33    0.00    0.00    0.00    0.00    0.00
Average:       1   97.33    0.00    1.67    0.00    0.33    0.67    0.00    0.00    0.00    0.00
Average:       2   42.33    0.00   57.33    0.00    0.33    0.00    0.00    0.00    0.00    0.00
Average:       3   34.33    0.00   65.00    0.00    0.33    0.33    0.00    0.00    0.00    0.00
Average:       4   88.63    0.00   11.04    0.00    0.00    0.33    0.00    0.00    0.00    0.00
Average:       5   71.33    0.00   28.33    0.00    0.33    0.00    0.00    0.00    0.00    0.00
Average:       6   95.65    0.00    4.01    0.00    0.00    0.33    0.00    0.00    0.00    0.00
Average:       7   99.67    0.00    0.00    0.00    0.33    0.00    0.00    0.00    0.00    0.00
```

Есть несколько важных вещей, которые следует отметить. Первая строка отображает полезные сведения:

* Ядро и выпуск: `5.14.0-362.8.1.el9_3.x86_64`
* Имя узла: `alma9`
* Дата: `02/21/24`
* Архитектура: `_x86_64_`
* Общий объем ЦП (эта информация полезна для интерпретации выходных данных других команд): `(8 CPU)`

Затем отображаются метрики для ЦП, чтобы объяснить каждый из столбцов:

* `Time`: время сбора образца
* `CPU`: числовые идентификаторы ЦП, идентификатор ALL является средним для всех ЦП.
* `%usr`: процент использования ЦП для пользовательского пространства, как правило, пользовательских приложений.
* `%nice`: процент использования ЦП для процессов пользовательского пространства с хорошим значением (приоритетом).
* `%sys`: процент использования ЦП для процессов пространства ядра.
* `%iowait`: процент времени, затраченного на простой ЦП, ожидающий невыполненных операций ввода-вывода.
* `%irq`: процент времени, затраченного на обслуживание аппаратных прерываний ЦП.
* `%soft`: процент времени, затраченного на обслуживание программного обеспечения.
* `%steal`: процент времени ЦП, затраченного на обслуживание других виртуальных машин (не применимо к Azure из-за отсутствия избыточной подготовки ЦП).
* `%guest`: процент времени, затраченного на обслуживание виртуальных ЦП (не применимо к Azure, применимо только к системам без операционной системы под управлением виртуальных машин).
* `%gnice`: процент времени, затраченного на обслуживание виртуальных ЦП с хорошим значением (не применимо к Azure, применимо только к системам без операционной системы под управлением виртуальных машин).
* `%idle`: процент времени, затраченного на простой ЦП, и без ожидания запросов ввода-вывода.

#### Вещи, чтобы искать

Некоторые сведения следует учитывать при просмотре выходных данных для `mpstat`:

* Убедитесь, что все ЦП загружены должным образом, а не один ЦП обслуживает всю нагрузку. Эти сведения могут указывать на одно потоковое приложение.
* Найдите здоровый баланс между `%usr` и `%sys` как противоположное означает больше времени, потраченного на фактическую рабочую нагрузку, чем обслуживание процессов ядра.
* `%iowait` Найдите проценты в качестве высоких значений, которые могут указывать на систему, которая постоянно ожидает запросов ввода-вывода.
* Высокий `%soft` уровень использования может указывать на высокий сетевой трафик.

### `vmstat`

Эта `vmstat` программа широко доступна в большинстве дистрибутивов Linux, она предоставляет общие сведения об использовании ЦП, памяти и дискового ввода-вывода в одной области.
Для этой команды используется следующая команда `vmstat` :

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'vmstat -w 1 5')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Параметры и аргументы:

* `-w`: используйте широкую печать для поддержания согласованности столбцов.
* `1`: первый числовой аргумент указывает, как часто обновлять отображение в секундах.
* `5`: второй числовой аргумент указывает, сколько раз обновляются данные.

Результаты:

```output
--procs-- -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
   r    b         swpd         free         buff        cache   si   so    bi    bo   in   cs  us  sy  id  wa  st
  14    0            0     26059408          164       137468    0    0    89  3228   56  122   3   1  95   1   0
  14    1            0     24388660          164       145468    0    0     0  7811 3264 13870  76  24   0   0   0
  18    1            0     23060116          164       155272    0    0    44  8075 3704 15129  78  22   0   0   0
  18    1            0     21078640          164       165108    0    0   295  8837 3742 15529  73  27   0   0   0
  15    2            0     19015276          164       175960    0    0     9  8561 3639 15177  73  27   0   0   0
```

`vmstat` разделяет выходные данные на шесть групп:

* `procs`: статистика для процессов.
* `memory`: статистика для системной памяти.
* `swap`: статистика для переключения.
* `io`: статистика для операций ввода-вывода на диск.
* `system`: статистика для переключений контекста и прерываний.
* `cpu`: статистика использования ЦП.

>Примечание. `vmstat` Отображает общую статистику для всей системы (то есть все ЦП, все блоки устройств, агрегированные).

#### `procs`

В `procs` разделе есть два столбца:

* `r`: количество выполняемых процессов в очереди выполнения.
* `b`: количество процессов, заблокированных в ожидании ввода-вывода.

В этом разделе немедленно показано, есть ли узкие места в системе. Большое число в любом из столбцов указывает на процессы очереди ожидания ресурсов.

Столбец `r` указывает количество процессов, ожидающих запуска ЦП. Проще интерпретировать это число следующим образом: если количество процессов в `r` очереди выше, чем общее количество ЦП, то можно определить, что в системе сильно загружен ЦП, и он не может выделить время ЦП для всех процессов, ожидающих выполнения.

Столбец `b` указывает количество процессов, ожидающих выполнения, которые блокируются запросами ввода-вывода. Большое число в этом столбце указывает на систему, которая испытывает высокий уровень ввода-вывода, и процессы не могут выполняться из-за других процессов, ожидающих завершения запросов ввода-вывода. Это также может указывать на высокую задержку диска.

#### `memory`

Раздел памяти содержит четыре столбца:

* `swpd`: используемая память буфера суммы.
* `free`: объем свободного объема памяти.
* `buff`: объем памяти, используемой для буферов.
* `cache`: объем памяти, используемой для кэша.

> [!NOTE]
> Значения отображаются в байтах.

В этом разделе представлен общий обзор использования памяти.

#### `swap`

Раздел буфера содержит два столбца:

* `si`: объем переключения памяти (перемещается из системной памяти в секунду).
* `so`: объем переключения памяти (перемещен из переключения в системную память) в секунду.

Если наблюдается высокий `si` уровень, он может представлять собой систему, которая выходит из системной памяти и перемещает страницы для переключения (переключения).

#### `io`

В `io` разделе есть два столбца:

* `bi`: количество блоков, полученных от блочного устройства (считывает блоки в секунду) в секунду.
* `bo`: количество блоков, отправляемых на блочное устройство (записывает в секунду) в секунду.

> [!NOTE]
> Эти значения находятся в блоках в секунду.

#### `system`

В `system` разделе есть два столбца:

* `in`: количество прерываний в секунду.
* `cs`: число переключений контекста в секунду.

Большое количество прерываний в секунду может указывать на систему, занятую аппаратными устройствами (например, сетевыми операциями).

Большое количество переключателей контекста может указывать на занятую систему с множеством коротких процессов, здесь нет хорошего или плохого числа.

#### `cpu`

В этом разделе есть пять столбцов:

* `us`: использование процента пространства пользователя.
* `sy`: процент использования системного пространства (пространства ядра).
* `id`: процент использования времени простоя ЦП.
* `wa`: процент использования времени простоя ЦП ожидает обработки операций ввода-вывода.
* `st`: процент использования времени, затраченного ЦП на обслуживание других виртуальных ЦП (не применимо к Azure).

Значения представлены в процентах. Эти значения совпадают с `mpstat` служебной программой и служат для предоставления высокого уровня обзора использования ЦП. Следуйте аналогичному процессу для "[Вещи, чтобы искать](#mpstat)" при `mpstat` просмотре этих значений.

### `uptime`

Наконец, для метрик, связанных с ЦП, `uptime` программа предоставляет широкий обзор системной нагрузки со средними значениями нагрузки.

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'uptime')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

```output
16:55:53 up 9 min,  2 users,  load average: 9.26, 2.91, 1.18
```

Среднее значение нагрузки отображает три числа. Эти числа предназначены для `1``5` `15` и минутных интервалов системной нагрузки.

Чтобы интерпретировать эти значения, важно знать количество доступных ЦП в системе, полученных из `mpstat` выходных данных до. Значение зависит от общего ЦП, так что в качестве примера выходных `mpstat` данных система имеет 8 ЦП, средняя нагрузка 8 означает, что все ядра загружаются на 100 %.

Значение `4` будет означать, что половина ЦП была загружена на 100 % (или в общей сложности 50 % нагрузки на ВСЕ ЦП). В предыдущих выходных данных среднее значение нагрузки `9.26`— это означает, что ЦП загружается примерно на 115 %.

`5m``15m` Интервалы `1m`помогают определить, увеличивается ли нагрузка или уменьшается с течением времени.

> [ПРИМЕЧАНИЕ] Для `nproc` получения количества ЦП также можно использовать команду.

## Память

Для памяти существует две команды, которые могут получить сведения об использовании.

### `free`

Команда `free` показывает использование системной памяти.

Чтобы запустить его, выполните следующую команду:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'free -h')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Параметры и аргументы:

* `-h`: динамически отображать значения как доступные для чтения человеком (например, Mib, Gib, Tib)

Результаты:

```output
               total        used        free      shared  buff/cache   available
Mem:            31Gi        19Gi        12Gi        23Mi        87Mi        11Gi
Swap:           23Gi          0B        23Gi
```

В выходных данных найдите общую системную память и доступную и используемую общую переключение. Доступная память учитывает память, выделенную для кэша, которая может быть возвращена для пользовательских приложений.

Некоторые использование буферов обычно используется в современных ядрах, так как некоторые менее часто используемые страницы памяти можно переместить для переключения.

### `swapon`

Команда `swapon` отображает, где настроена переключение, а также соответствующие приоритеты устройств или файлов.

Для выполнения команды:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'swapon -s')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Результаты:

```output
Filename      Type          Size          Used   Priority
/dev/zram0    partition     16G           0B      100
/mnt/swapfile file          8G            0B      -2
```

Эта информация важна, чтобы проверить, настроена ли переключение в расположении, которое не идеально подходит, например на диске данных или ОС. В временного дисках Azure следует настроить переключение на эфемерном диске, так как оно обеспечивает лучшую производительность.

### Вещи, чтобы искать

* Помните, что память является конечным ресурсом, как только системная память (ОЗУ) и переключение исчерпаны, процессы должны быть убиты убийцей Out Of Memorry (OOM).
* Убедитесь, что переключение не настроено на диске данных или на диске ОС, так как это приведет к проблемам с вводом-выводом из-за различий в задержке. Переключение должно быть настроено на эфемерном диске.
* Следует также учитывать, что `free -h` в выходных данных о том, что свободные значения близки к нулю, это поведение обусловлено кэшем страниц, ядро освобождает эти страницы по мере необходимости.

## ВВОД-ВЫВОД

Операции ввода-вывода на диске — это одна из областей, в которых Azure страдает чаще всего при регулировании, так как диски могут достигать `100ms+` задержки. Следующие команды помогают определить эти сценарии.

### `iostat`

Программа `iostat` является частью `sysstat` пакета. Он отображает статистику использования блочных устройств и помогает выявлять связанные с блоком проблемы с производительностью.

Эта `iostat` программа содержит сведения о таких метриках, как пропускная способность, задержка и размер очереди. Эти метрики помогают понять, становится ли объем операций ввода-вывода диска ограничивающим фактором.
Чтобы выполнить команду, выполните следующую команду:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'iostat -dxtm 1 5')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Параметры и аргументы:

* `-d`: отчет об использовании устройства.
* `-x`: расширенная статистика.
* `-t`: отображение метки времени для каждого отчета.
* `-m`: отображается в МБ/с.
* `1`: первый числовой аргумент указывает, как часто обновлять отображение в секундах.
* `2`: второй числовой аргумент указывает, сколько раз обновляются данные.

Результаты:

```output
Linux 5.14.0-362.8.1.el9_3.x86_64 (alma9)       02/21/24        _x86_64_        (8 CPU)

02/21/24 16:55:50
Device            r/s     rMB/s   rrqm/s  %rrqm r_await rareq-sz     w/s     wMB/s   wrqm/s  %wrqm w_await wareq-sz     d/s     dMB/s   drqm/s  %drqm d_await dareq-sz     f/s f_await  aqu-sz  %util
sda              1.07      0.02     0.00   0.00    1.95    20.40   23.25     24.55     3.30  12.42  113.75  1081.06    0.26    537.75     0.26  49.83    0.03 2083250.04    0.00    0.00    2.65   2.42
sdb             16.99      0.67     0.36   2.05    2.00    40.47   65.26      0.44     1.55   2.32    1.32     6.92    0.00      0.00     0.00   0.00    0.00     0.00   30.56    1.30    0.16   7.16
zram0            0.51      0.00     0.00   0.00    0.00     4.00    0.00      0.00     0.00   0.00    0.00     4.00    0.00      0.00     0.00   0.00    0.00     0.00    0.00    0.00    0.00   0.00

```

Выходные данные имеют несколько столбцов, которые не важны (дополнительные столбцы из-за `-x` параметра), некоторые из важных:

* `r/s`: операции чтения в секунду (операции ввода-вывода в секунду).
* `rMB/s`: чтение мегабайт в секунду.
* `r_await`: задержка чтения в миллисекундах.
* `rareq-sz`: средний размер запроса чтения в килобайтах.
* `w/s`: операции записи в секунду (операции ввода-вывода в секунду).
* `wMB/s`: записывайте мегабайты в секунду.
* `w_await`: задержка записи в миллисекундах.
* `wareq-size`: средний размер запроса записи в килобайтах.
* `aqu-sz`: средний размер очереди.

#### Вещи, чтобы искать

* `r/s` Найдите и `w/s` (ioPS) и `rMB/s` `wMB/s` убедитесь, что эти значения находятся в пределах заданного диска. Если значения закрываются или выше, диск будет регулироваться, что приводит к высокой задержке. Эти сведения также можно подтвердить с `%iowait` помощью метрик из `mpstat`.
* Задержка является отличной метрикой, чтобы проверить, выполняется ли диск должным образом. Как правило, меньше `9ms` ожидаемой задержки для PremiumSSD, другие предложения имеют разные целевые показатели задержки.
* Размер очереди является большим индикатором насыщенности. Как правило, запросы будут обслуживаться практически в режиме реального времени, и число остается близко к одному (так как очередь никогда не растет). Более высокое число может указывать на насыщенность диска (то есть запросы в очередь). Для этой метрики нет хорошего или плохого числа. Понимание того, что все выше одного означает, что запросы очереди помогают определить, есть ли насыщенность диска.

### `lsblk`

В `lsblk` служебной программе показаны блоковые устройства, подключенные к системе, в то время как они не предоставляют метрики производительности, это позволяет быстро узнать, как настроены эти устройства и какие точки подключения используются.

Чтобы выполнить команду, выполните следующую команду:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'lsblk')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Результаты:

```output
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda      8:0    0  300G  0 disk
└─sda1   8:1    0  300G  0 part /mnt
sdb      8:16   0   30G  0 disk
├─sdb1   8:17   0    1M  0 part
├─sdb2   8:18   0  200M  0 part /boot/efi
├─sdb3   8:19   0    1G  0 part /boot
└─sdb4   8:20   0 28.8G  0 part /
zram0  252:0    0   16G  0 disk [SWAP]
```

#### Вещи, чтобы искать

* Найдите место подключения устройств.
* Убедитесь, что переключение не настроено внутри диска данных или диска ОС, если он включен.

> Примечание. Простой способ сопоставления блочного устройства с LUN в Azure выполняется `ls -lr /dev/disk/azure`.

## Обработка

Сбор сведений о каждом процессе помогает понять, откуда поступает нагрузка системы.

Основная программа сбора статических процессов заключается `pidstat` в том, что она предоставляет сведения о каждом процессе для статистики ЦП, памяти и ввода-вывода.

Наконец, простой `ps` процесс сортировки по верхнему ЦП и использованию памяти завершает метрики.

> [!NOTE]
> Так как эти команды отображают сведения о выполнении процессов, они должны выполняться в качестве корневого каталога `sudo`. Эта команда позволяет отображать все процессы, а не только пользователя.

### `pidstat`

Программа `pidstat` также является частью `sysstat` пакета. Это как `mpstat` или iostat, где он отображает метрики в течение определенного периода времени. По умолчанию `pidstat` отображаются только метрики для процессов с действием.

Аргументы для `pidstat` других `sysstat` служебных программ одинаковы:

* 1. Первый числовой аргумент указывает, как часто обновлять отображение в секундах.
* 2. Второй числовой аргумент указывает, сколько раз обновляются данные.

> [!NOTE]
> Выходные данные могут значительно расти, если есть много процессов с действием.

#### Обработка статистики ЦП

Чтобы собрать статистику ЦП процесса, запустите без `pidstat` каких-либо параметров:

Следующие команды можно использовать, если вы хотите выполнить его из Azure CLI:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'pidstat 1 2')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Результаты:

```output
Linux 5.14.0-362.8.1.el9_3.x86_64 (alma9)       02/21/24        _x86_64_        (8 CPU)

# Time        UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:55:48        0        66    0.0%    1.0%    0.0%    0.0%    1.0%     0  kworker/u16:2-xfs-cil/sdb4
16:55:48        0        70    0.0%    1.0%    0.0%    0.0%    1.0%     0  kworker/u16:6-xfs-cil/sdb4
16:55:48        0        92    0.0%    1.0%    0.0%    0.0%    1.0%     3  kworker/3:1H-kblockd
16:55:48        0       308    0.0%    1.0%    0.0%    0.0%    1.0%     1  kworker/1:1H-kblockd
16:55:48        0      2068    0.0%    1.0%    0.0%    0.0%    1.0%     1  kworker/1:3-xfs-conv/sdb4
16:55:48        0      2181   63.1%    1.0%    0.0%   35.9%   64.1%     5  stress-ng-cpu
16:55:48        0      2182   28.2%    0.0%    0.0%   70.9%   28.2%     6  stress-ng-cpu
16:55:48        0      2183   28.2%    0.0%    0.0%   69.9%   28.2%     7  stress-ng-cpu
16:55:48        0      2184   62.1%    0.0%    0.0%   36.9%   62.1%     0  stress-ng-cpu
16:55:48        0      2185   43.7%    0.0%    0.0%   54.4%   43.7%     2  stress-ng-cpu
16:55:48        0      2186   30.1%    0.0%    0.0%   68.0%   30.1%     7  stress-ng-cpu
16:55:48        0      2187   64.1%    0.0%    0.0%   34.0%   64.1%     3  stress-ng-cpu
```

Команда отображает использование каждого процесса для `%usr`, `%system``%guest` (не применимо к Azure) `%wait`и общее `%CPU` использование.

##### Вещи, чтобы искать

* Найдите процессы с высоким процентом %wait (iowait), так как это может указывать на процессы, которые блокируются в ожидании ввода-вывода, что также может указывать на насыщенность диска.
* Убедитесь, что ни один процесс не потребляет 100 % ЦП, так как это может указывать на одно потоковое приложение.

#### Статистика памяти обработки

Чтобы собрать статистику памяти процесса, используйте `-r` этот параметр:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'pidstat -r 1 2')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Результаты:

```output
Linux 5.14.0-362.8.1.el9_3.x86_64 (alma9)       02/21/24        _x86_64_        (8 CPU)

# Time        UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
16:55:49        0      2199 119244.12      0.00   13.6G    7.4G  23.5%  stress-ng-vm
16:55:49        0      2200 392911.76      0.00   13.6G    9.3G  29.7%  stress-ng-vm
16:55:49        0      2211   1129.41      0.00   72.3M    3.2M   0.0%  stress-ng-iomix
16:55:49        0      2220      0.98      0.00   71.8M    2.4M   0.0%  stress-ng-iomix
16:55:49        0      2239   1129.41      0.00   72.3M    3.2M   0.0%  stress-ng-iomix
16:55:49        0      2240   1129.41      0.00   72.3M    3.2M   0.0%  stress-ng-iomix
16:55:49        0      2256      0.98      0.00   71.8M    2.4M   0.0%  stress-ng-iomix
16:55:49        0      2265   1129.41      0.00   72.3M    3.2M   0.0%  stress-ng-iomix
```

Собранные метрики:

* `minflt/s`: незначительные ошибки в секунду, эта метрика указывает количество страниц, загруженных из системной памяти (ОЗУ).
* `mjflt/s`: основные ошибки в секунду, эта метрика указывает количество страниц, загруженных с диска (SWAP).
* `VSZ`: виртуальная память, используемая в байтах.
* `RSS`: резидентная память, используемая (фактическая выделенная память) в байтах.
* `%MEM`: процент используемой общей памяти.
* `Command`: имя процесса.

##### Вещи, чтобы искать

* Найдите крупные ошибки в секунду, так как это значение будет указывать на процесс переключения страниц на диск или с диска. Это поведение может указывать на нехватку памяти и может привести к `OOM` событиям или снижению производительности из-за более медленного переключения.
* Убедитесь, что один процесс не потребляет 100 % доступной памяти. Это поведение может указывать на утечку памяти.

> [!NOTE]
> параметр `--human` можно использовать для отображения чисел в удобочитаемом формате (т `Kb`. е. , `Mb`, `GB`).

#### Статистика операций ввода-вывода обработки

Чтобы собрать статистику памяти процесса, используйте `-d` этот параметр:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'pidstat -d 1 2')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

Результаты:

```outputLinux 5.14.0-362.8.1.el9_3.x86_64 (alma9)       02/21/24        _x86_64_        (8 CPU)

# Time        UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
16:55:50        0        86     55.4k      0.0B      0.0B       0  kworker/1:1-xfs-conv/sdb4
16:55:50        0      2201      4.0k    194.1k      0.0B       0  stress-ng-iomix
16:55:50        0      2202      0.0B     99.0k      0.0B       0  stress-ng-iomix
16:55:50        0      2203      0.0B     23.8k      0.0B       0  stress-ng-iomix
16:55:50        0      2204      0.0B     15.8k      0.0B       0  stress-ng-iomix
16:55:50        0      2212      0.0B    103.0k      0.0B       0  stress-ng-iomix
16:55:50        0      2213      4.0k     99.0k      0.0B       0  stress-ng-iomix
16:55:50        0      2215      0.0B    178.2k      0.0B       0  stress-ng-iomix
16:55:50        0      2216      7.9k    237.6k      0.0B       0  stress-ng-iomix
16:55:50        0      2218      0.0B     95.0k      0.0B       0  stress-ng-iomix
16:55:50        0      2221      0.0B     15.8k      0.0B       0  stress-ng-iomix
```

Собранные метрики:

* `kB_rd/s`: чтение килобайтов в секунду.
* `kB_wr/s`: запись килобайтов в секунду.
* `Command`: имя процесса.

##### Вещи, чтобы искать

* Поиск отдельных процессов с высокой скоростью чтения и записи в секунду. Эти сведения являются рекомендациями по процессам с вводом-выводом больше, чем выявление проблем.
Примечание. Параметр `--human` можно использовать для отображения чисел в удобочитаемом формате (т `Kb`. е. , `Mb`, `GB`).

### `ps`

`ps` Наконец, команда отображает системные процессы и может быть отсортирована по ЦП или памяти.

Чтобы отсортировать по ЦП и получить первые 10 процессов:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'ps aux --sort=-%cpu | head -10')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

```output
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root        2190 94.8  0.0  73524  5588 pts/1    R+   16:55   0:14 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2200 56.8 43.1 14248092 14175632 pts/1 R+ 16:55   0:08 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2192 50.6  0.0  73524  5836 pts/1    R+   16:55   0:07 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2184 50.4  0.0  73524  5836 pts/1    R+   16:55   0:07 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2182 44.3  0.0  73524  5808 pts/1    R+   16:55   0:06 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2187 43.4  0.0  73524  5708 pts/1    R+   16:55   0:06 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2199 42.9 33.0 14248092 10845272 pts/1 R+ 16:55   0:06 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2186 42.0  0.0  73524  5836 pts/1    R+   16:55   0:06 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2191 41.2  0.0  73524  5592 pts/1    R+   16:55   0:06 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
```

Чтобы отсортировать и получить первые 10 процессов, выполните следующие `MEM%` действия.

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'ps aux --sort=-%mem| head -10')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted"
```

```output
       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root        2200 57.0 43.1 14248092 14175632 pts/1 R+ 16:55   0:08 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        2199 43.0 33.0 14248092 10871144 pts/1 R+ 16:55   0:06 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
root        1231  0.2  0.1 336308 33764 ?        Sl   16:46   0:01 /usr/bin/python3 -u bin/WALinuxAgent-2.9.1.1-py3.8.egg -run-exthandlers
root         835  0.0  0.0 127076 24860 ?        Ssl  16:46   0:00 /usr/bin/python3 -s /usr/sbin/firewalld --nofork --nopid
root        1199  0.0  0.0  30164 15600 ?        Ss   16:46   0:00 /usr/bin/python3 -u /usr/sbin/waagent -daemon
root           1  0.2  0.0 173208 12356 ?        Ss   16:46   0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
root         966  0.0  0.0 3102460 10936 ?       Sl   16:46   0:00 /var/lib/waagent/Microsoft.GuestConfiguration.ConfigurationforLinux-1.26.60/GCAgent/GC/gc_linux_service
panzer      1803  0.0  0.0  22360  8220 ?        Ss   16:49   0:00 /usr/lib/systemd/systemd --user
root        2180  0.0  0.0  73524  6968 pts/1    SL+  16:55   0:00 stress-ng --cpu 12 --vm 2 --vm-bytes 120% --iomix 4 --timeout 240
```

## Объединение всех вместе

Простой скрипт bash может собирать все сведения в одном запуске и добавлять выходные данные в файл для последующего использования:

```azurecli-interactive
output=$(az vm run-command invoke --resource-group $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts 'mpstat -P ALL 1 2 && vmstat -w 1 5 && uptime && free -h && swapon && iostat -dxtm 1 1 && lsblk && ls -l /dev/disk/azure && pidstat 1 1 -h --human && pidstat -r 1 1 -h --human && pidstat -d 1 1 -h --human && ps aux --sort=-%cpu | head -20 && ps aux --sort=-%mem | head -20')
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted" 
```

Для выполнения можно создать файл с указанным выше содержимым, добавить разрешения на выполнение, выполнив `chmod +x gather.sh`и выполнив команду `sudo ./gather.sh`.

Этот скрипт сохраняет выходные данные команд в файле, расположенном в том же каталоге, где был вызван скрипт.

Кроме того, все команды в кодах блоков Bash, описанных в этом документе, можно выполнять `az-cli` с помощью расширения run-command и анализировать выходные данные, чтобы получить аналогичные выходные данные `jq` для выполнения команд локально: '

```azurecli-interactive
output=$(az vm run-command invoke -g $MY_RESOURCE_GROUP_NAME --name $MY_VM_NAME --command-id RunShellScript --scripts "ls -l /dev/disk/azure")
value=$(echo "$output" | jq -r '.value[0].message')
extracted=$(echo "$value" | awk '/\[stdout\]/,/\[stderr\]/' | sed '/\[stdout\]/d' | sed '/\[stderr\]/d')
echo "$extracted" 
```